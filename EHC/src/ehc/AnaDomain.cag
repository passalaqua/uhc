%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analysis domains
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to AnaDomain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}AnaDomain} import({%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Opts.Base},{%{EH}VarMp})
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map,qualified Data.Set as Set, Data.List, Data.Maybe)
%%]
%%[(8 codegen) hs import(Control.Monad.State hiding (join), Control.Applicative)
%%]
%%[(8 codegen) hs import(UHC.Util.Utils)
%%]

%%[(8 codegen) hs export(RelTyScheme(..), RelTySchemeL, RelTy(..), RelTyL, Relev(..), Rho, Applic(..), TyAGItf(..))
%%]

%%[(50 codegen grin) hs import(Control.Monad hiding(join), UHC.Util.Serialize, UHC.Util.Control.Monad(liftM6))
%%]
%%[(50 codegen grin) hs import(Data.Typeable(Typeable), Data.Generics(Data))
%%]

%%[(8 codegen) ag import({AnaDomain/AbsSyn})
DERIVING *
  : Show
%%[[50
  , Typeable, Data
%%]]

DERIVING *
  : Eq, Ord
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},UHC.Util.Pretty)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Derived types, functions, ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
data AnaEnv
  = AnaEnv
      { aenvEnv  :: !UIDS
      }

emptyAnaEnv :: AnaEnv
emptyAnaEnv = AnaEnv Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lattices (should be in separate module)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(AnaLattice(..))
class AnaLattice a where
  top   :: a
  bot   :: a

  isTop :: a -> Bool
  isBot :: a -> Bool
  isVar :: a -> Maybe UID

  fresh :: UID -> a

  meet  :: a -> a -> Maybe a
  join  :: a -> a -> Maybe a
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lattice instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
instance AnaLattice Relev where
  top   = Relev_Top
  bot   = Relev_Rel

  isTop Relev_Top = True
  isTop _         = False

  isBot Relev_Rel = True
  isBot _         = False

  isVar (Relev_Beta b) = Just b
  isVar _              = Nothing

  fresh = Relev_Beta

  meet _ _ = panic "Meet Relev"
  join _ _ = panic "Join Relev"

instance AnaLattice Applic where
  top   = Applic_Top
  bot   = Applic_App
  
  isTop Applic_Top = True
  isTop _          = False

  isBot Applic_App = True
  isBot _          = False

  isVar (Applic_Gamma v _) = Just v
  isVar _                  = Nothing

  fresh uid = Applic_Gamma uid []

  meet _ _ = panic "Meet Applic"
  join _ _ = panic "Join Applic"
%%]

%%%[8 hs
-- | meet or join for 2 element lattice (only bot+top), nothing in between
anaMeetOrJoin
  :: AnaLattice x
     => (UID -> x -> RVarMp)		-- make var mapping (subst)
     -> Bool						-- is meet (True) or join (False)
     -> x -> x
     -> Maybe x
anaMeetOrJoin mkVM isM a1 a2
  = mt False a1 a2
  where mt flip a1 a2
          | isB && isM  = Just a1
          | isB         = Just a2
          | isT && isM  = Just a2
          | isT         = Just a1
          | not flip    = mt True a2 a1
          | isJust m1 && isJust m2
                        = do { s <- get
                             ; let bound = amsBoundS s
                             ;      if not (v1 `Set.member` bound) then bind v1 a2
                               else if not (v2 `Set.member` bound) then bind v2 a1
                               else Nothing
                             }
          | otherwise   = Nothing
                        where m1@(~(Just v1)) = isVar a1
                              m2@(~(Just v2)) = isVar a2
                              -- areV = isJust m1 && isJust m2
                              isB  = isBot a1
                              isT  = isTop a1
        bind = anaBind mkVM Just

-- | meet, join, specialized for AnaEval
anaEvalMeet, anaEvalJoin :: AnaEval -> AnaEval -> AMS (Maybe AnaEval)
anaEvalMeet = anaMeetOrJoin rvarmpEvalUnit True
anaEvalJoin = anaMeetOrJoi  n rvarmpEvalUnit False
%%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(RVarMpInfo(..))
data RVarMpInfo             -- for all types of Var alternatives an alternative here
  = RVMIType    RelTy       -- Type variable substitution
  | RVMIRelev
  | RVMIApplic
%%]

%%[(8 codegen) hs export(rvmiMbEval)
rvmiMbEval :: RVarMpInfo -> Maybe RelTy
rvmiMbEval (RVMIType x) = Just x
rvmiMbEval _            = Nothing
%%]

%%[(8 codegen) hs export(RVarMp, emptyRVarMp)
type RVarMp  = VarMpStk' UID RVarMpInfo

emptyRVarMp :: RVarMp
emptyRVarMp = emptyVarMpStk
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances: Binary, Serialize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen) hs
instance Serialize RelTyScheme where
  sput (RelTyScheme_Tau     ty  ) = sputWord8 0 >> sput ty
  sput (RelTyScheme_FAAlpha ty a) = sputWord8 1 >> sput ty >> sput a
  sput (RelTyScheme_FABeta  ty b) = sputWord8 2 >> sput ty >> sput b
  sput (RelTyScheme_FAGamma ty g) = sputWord8 3 >> sput ty >> sput g
  sget
    = do t <- sgetWord8
         case t of
           0 -> liftM  RelTyScheme_Tau     sget
           1 -> liftM2 RelTyScheme_FAAlpha sget sget
           2 -> liftM2 RelTyScheme_FABeta  sget sget
           3 -> liftM2 RelTyScheme_FAGamma sget sget

instance Serialize RelTy where
  sput (RelTy_Unit               ) = sputWord8 0
  sput (RelTy_Alpha v            ) = sputWord8 1 >> sput v
  sput (RelTy_Arrow re ap arg res) = sputWord8 2 >> sput re >> sput ap >> sput arg >> sput res
  sput (RelTy_Data  ps           ) = sputWord8 3 >> sput ps
  sget
    = do t <- sgetWord8
         case t of
           0 -> return RelTy_Unit
           1 -> liftM  RelTy_Alpha sget
           2 -> liftM4 RelTy_Arrow sget sget sget sget
           3 -> liftM  RelTy_Data sget

instance Serialize Relev where
  sput (Relev_Top   ) = sputWord8 0
  sput (Relev_Rel   ) = sputWord8 1
  sput (Relev_Beta v) = sputWord8 2 >> sput v
  sget
    = do t <- sgetWord8
         case t of
           0 -> return Relev_Top
           1 -> return Relev_Rel
           2 -> liftM  Relev_Beta sget

instance Serialize Applic where
  sput (Applic_Top      ) = sputWord8 0
  sput (Applic_App      ) = sputWord8 1
  sput (Applic_Gamma v d) = sputWord8 2 >> sput v >> sput d
  sget
    = do t <- sgetWord8
         case t of
           0 -> return Applic_Top
           1 -> return Applic_App
           2 -> liftM2 Applic_Gamma sget sget
%%]
