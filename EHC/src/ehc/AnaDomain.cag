%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analysis domains
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to AnaDomain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}AnaDomain} import({%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Opts.Base},{%{EH}VarMp})
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map,qualified Data.Set as Set, Data.List, Data.Maybe)
%%]
%%[(8 codegen) hs import(Control.Monad.State hiding (join), Control.Applicative)
%%]
%%[(8 codegen) hs import(UHC.Util.Utils)
%%]

%%[(8 codegen) hs export(RelTyScheme(..), RelTy(..), RelTyL, Relev(..), Rho, Applic(..), TyAGItf(..))
%%]

%%[(50 codegen grin) hs import(Control.Monad hiding(join), UHC.Util.Serialize, UHC.Util.Control.Monad(liftM6))
%%]
%%[(50 codegen grin) hs import(Data.Typeable(Typeable), Data.Generics(Data))
%%]

%%[(8 codegen) ag import({AnaDomain/AbsSyn})
DERIVING *
  : Show
%%[[50
  , Typeable, Data
%%]]

DERIVING *
  : Eq, Ord
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},UHC.Util.Pretty)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Derived types, functions, ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Special values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(freshUnit, freshData, freshAlpha, freshArrow, makeArrow, freshTySch)
-- | Generates a simple Unit type.
freshUnit :: RelTyScheme
freshUnit = freshTySch RelTy_Unit

-- | Generates a new datatype
freshData :: CTag -> RelTyScheme
freshData t = freshTySch $ RelTy_Data t []

-- | Generates a fresh type variable type
freshAlpha :: UID -> RelTyScheme
freshAlpha u = freshTySch $ RelTy_Alpha u

-- | Generates a fresh arrow type with no relevance or aplicativeness
freshArrow :: RelTyScheme -> RelTyScheme -> RelTyScheme
freshArrow = makeArrow Relev_Top Applic_Top

-- | Makes an arrow from two types with fresh types
makeArrow :: Relev -> Applic -> RelTyScheme -> RelTyScheme -> RelTyScheme
makeArrow r a rt1 rt2 = let (ret, t1, t2) = rt1 `mergeTySch` rt2
                        in  ret (RelTy_Arrow r a t1 t2)

-- | Generates a fresh type scheme with no quantifications.
freshTySch :: RelTy -> RelTyScheme
freshTySch = RelTyScheme_Ty Set.empty Set.empty Set.empty

-- | Auxiliary function to help merging two type schemes.
mergeTySch :: RelTyScheme -> RelTyScheme -> (RelTy -> RelTyScheme, RelTy, RelTy)
mergeTySch (RelTyScheme_Ty a1 b1 g1 t1) (RelTyScheme_Ty a2 b2 g2 t2) =
  (RelTyScheme_Ty (a1 `Set.union` a2) (b1 `Set.union` b2) (g1 `Set.union` g2), t1, t2)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
data AnaEnv
  = AnaEnv
      { aenvEnv  :: !UIDS
      }

emptyAnaEnv :: AnaEnv
emptyAnaEnv = AnaEnv Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lattices (should be in separate module)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(AnaLattice(..))
class (Eq a) => AnaLattice a where
  top   :: a
  bot   :: a

  isTop :: a -> Bool
  isTop = (==top)
  isBot :: a -> Bool
  isBot = (==bot)
  isVar :: a -> Maybe UID

  fresh :: UID -> a

  meetOp :: a -> a -> a
  meet  :: a -> a -> a
  meet a b | isBot a || isBot b = bot
           | isTop a = b
           | isTop b = a
           | otherwise = a `meetOp` b
  joinOp :: a -> a -> a
  join  :: a -> a -> a
  join a b | isTop a || isTop b = top
           | isBot a = b
           | isBot b = a
           | otherwise = a `joinOp` b
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lattice instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
instance AnaLattice Relev where
  top   = Relev_Top
  bot   = Relev_Rel

  isVar (Relev_Beta b) = Just b
  isVar _              = Nothing

  fresh = Relev_Beta

  meetOp = Relev_Meet
  joinOp = Relev_Join

instance AnaLattice Applic where
  top   = Applic_Top
  bot   = Applic_App

  isVar (Applic_Gamma v _) = Just v
  isVar _                  = Nothing

  fresh uid = Applic_Gamma uid []

  meetOp = Applic_Meet
  joinOp = Applic_Join
%%]

%%%[8 hs
-- | meet or join for 2 element lattice (only bot+top), nothing in between
anaMeetOrJoin
  :: AnaLattice x
     => (UID -> x -> RVarMp)		-- make var mapping (subst)
     -> Bool						-- is meet (True) or join (False)
     -> x -> x
     -> Maybe x
anaMeetOrJoin mkVM isM a1 a2
  = mt False a1 a2
  where mt flip a1 a2
          | isB && isM  = Just a1
          | isB         = Just a2
          | isT && isM  = Just a2
          | isT         = Just a1
          | not flip    = mt True a2 a1
          | isJust m1 && isJust m2
                        = do { s <- get
                             ; let bound = amsBoundS s
                             ;      if not (v1 `Set.member` bound) then bind v1 a2
                               else if not (v2 `Set.member` bound) then bind v2 a1
                               else Nothing
                             }
          | otherwise   = Nothing
                        where m1@(~(Just v1)) = isVar a1
                              m2@(~(Just v2)) = isVar a2
                              -- areV = isJust m1 && isJust m2
                              isB  = isBot a1
                              isT  = isTop a1
        bind = anaBind mkVM Just

-- | meet, join, specialized for AnaEval
anaEvalMeet, anaEvalJoin :: AnaEval -> AnaEval -> AMS (Maybe AnaEval)
anaEvalMeet = anaMeetOrJoin rvarmpEvalUnit True
anaEvalJoin = anaMeetOrJoi  n rvarmpEvalUnit False
%%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(RVarMpInfo(..))
data RVarMpInfo             -- for all types of Var alternatives an alternative here
  = RVMIType    RelTy       -- Type variable substitution
  | RVMIRelev   Relev
  | RVMIApplic  Applic
%%]

%%[(8 codegen) hs export(rvmiMbTy, rvmiMbRel, rvmiMbApp)
rvmiMbTy :: RVarMpInfo -> Maybe RelTy
rvmiMbTy (RVMIType x) = Just x
rvmiMbTy _            = Nothing

rvmiMbRel :: RVarMpInfo -> Maybe Relev
rvmiMbRel (RVMIRelev x) = Just x
rvmiMbRel _             = Nothing

rvmiMbApp :: RVarMpInfo -> Maybe Applic
rvmiMbApp (RVMIApplic x) = Just x
rvmiMbApp _              = Nothing
%%]

%%[(8 codegen) hs export(RVarMp, emptyRVarMp, rvmpRelTy, rvmpRelev, rvmpApplic)
type RVarMp  = VarMpStk' UID RVarMpInfo

emptyRVarMp :: RVarMp
emptyRVarMp = emptyVarMpStk

rvmpRelTy :: UID -> RelTy -> RVarMp
rvmpRelTy u t = varmpstkUnit u (RVMIType t)

rvmpRelev :: UID -> Relev -> RVarMp
rvmpRelev u r = varmpstkUnit u (RVMIRelev r)

rvmpApplic :: UID -> Applic -> RVarMp
rvmpApplic u a = varmpstkUnit u (RVMIApplic a)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances: Binary, Serialize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen) hs
instance Serialize RelTyScheme where
  sput (RelTyScheme_Ty as bs gs ty) = sput as >> sput bs >> sput gs >> sput ty
  sget = liftM4 RelTyScheme_Ty sget sget sget sget

instance Serialize RelTy where
  sput (RelTy_Unit               ) = sputWord8 0
  sput (RelTy_Alpha v            ) = sputWord8 1 >> sput v
  sput (RelTy_Arrow re ap arg res) = sputWord8 2 >> sput re >> sput ap >> sput arg >> sput res
  sput (RelTy_Data t ps          ) = sputWord8 3 >> sput t >> sput ps
  sget
    = do t <- sgetWord8
         case t of
           0 -> return RelTy_Unit
           1 -> liftM  RelTy_Alpha sget
           2 -> liftM4 RelTy_Arrow sget sget sget sget
           3 -> liftM2 RelTy_Data sget sget

instance Serialize Relev where
  sput (Relev_Top     ) = sputWord8 0
  sput (Relev_Rel     ) = sputWord8 1
  sput (Relev_Beta v  ) = sputWord8 2 >> sput v
  sput (Relev_Meet a b) = sputWord8 3 >> sput a >> sput b
  sput (Relev_Join a b) = sputWord8 4 >> sput a >> sput b
  sget
    = do t <- sgetWord8
         case t of
           0 -> return Relev_Top
           1 -> return Relev_Rel
           2 -> liftM  Relev_Beta sget
           3 -> liftM2 Relev_Meet sget sget
           4 -> liftM2 Relev_Join sget sget

instance Serialize Applic where
  sput (Applic_Top      ) = sputWord8 0
  sput (Applic_App      ) = sputWord8 1
  sput (Applic_Gamma v d) = sputWord8 2 >> sput v >> sput d
  sput (Applic_Meet  a b) = sputWord8 3 >> sput a >> sput b
  sput (Applic_Join  a b) = sputWord8 4 >> sput a >> sput b
  sget
    = do t <- sgetWord8
         case t of
           0 -> return Applic_Top
           1 -> return Applic_App
           2 -> liftM2 Applic_Gamma sget sget
           3 -> liftM2 Applic_Meet sget sget
           4 -> liftM2 Applic_Join sget sget
%%]
