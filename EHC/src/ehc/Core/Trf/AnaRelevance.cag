%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analyse Core, using relevance analysis, to relate properties (like relevance) of function args and result, and annotate core expressions with their relevance.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type based simplifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.AnaRelevance} import({%{EH}Ty},{%{EH}Base.Common},{%{EH}Base.TermLike},{%{EH}Base.Builtin},{%{EH}Gam},{%{EH}Opts},{%{EH}Base.Optimize},{%{EH}Core},{%{EH}VarMp},{%{EH}Substitutable})
%%]

%%[(8 codegen) hs import(Data.Maybe, qualified Data.Map as Map, qualified Data.Set as Set, Control.Applicative)
%%]

%%[(8 codegen) hs import(UHC.Util.Utils)
%%]

%%[(8 codegen) hs import({%{EH}Foreign.Extract})
%%]
%%[(90 codegen) hs import({%{EH}BuiltinPrims},{%{EH}Foreign})
%%]

%%[(8 codegen) hs import({%{EH}AbstractCore},{%{EH}AnaDomain},{%{EH}AnaDomain.Utils})
%%]

%%[(8 codegen) hs import({%{EH}Gam},{%{EH}Gam.DataGam})
%%]

%%[(8 codegen) hs import({%{EH}BindingInfo})
%%]

%%[(8 codegen) hs import({%{EH}AnaDomain.Trf.Instantiate})
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},UHC.Util.Pretty,{%{EH}AnaDomain.Pretty})
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonFFI},{Core/CommonBindNm},{Core/Trf/CommonStructureInfo},{Core/CommonCtxtPred},{Core/Trf/CommonFv},{Core/CommonBindingInfo},{Core/CommonGathBindingInfo})
WRAPPER CodeAGItf
%%]

%%[(99 codegen)
-- PRAGMA strictcase
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmodTrfAnaRelevance)
cmodTrfAnaRelevance
  :: EHCOpts
     -> DataGam
     -> BindingMp
     -> CModule
     -> ( CModule
        , BindingMp
        )
cmodTrfAnaRelevance
     opts dataGam
     bindingMp
     cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { dataGam_Inh_CodeAGItf = dataGam
                               , bindingMp_Inh_CodeAGItf = bindingMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , gathBindingMp_Syn_CodeAGItf t
          )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering BindingInfo, providing hook for Core/CommonBindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .	howUnionGathBindingInfo
  												=	id
%%]

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .   howMergeBindingInfo	=   (\(BindingInfo {bindinginfoAspMp=m}) i -> i {bindinginfoAspMp = m `Map.union` bindinginfoAspMp i})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Newly bound BindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%[(8 codegen grin)
SEM CBound
  | Bind        lhs         .   bindingMp   =   let l = [ (acbaspkeyDefaultRelevTy, BindingInfoAsp_RelevTy @bindTy) ]
                                                    in  Map.singleton @lhs.nm (emptyBindingInfo {bindinginfoAspMp = Map.fromList l})
%%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam required tags (strictness info), FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type sigs for AG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM *
  | *           loc         .   exprEnv         :   REnv
                loc         .   applic          :   Rho
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type REnv    = Gam HsName (RelTyScheme, Relev)

type RhoEnv  = Gam UID (Set.Set UID)

-- | lookup in local REnv only
renvLookup :: HsName -> REnv -> Maybe (RelTyScheme, Relev)
renvLookup = gamLookup

-- | lookup in REnv first, then global BindingMp
renvgLookup :: HsName -> REnv -> BindingMp -> Maybe RelTyScheme
renvgLookup n renv lammp = (fmap fst $ renvLookup n renv)
                           <|> (fmap libindaspRelevTy $ bindingMpLookupAsp n acbaspkeyDefaultRelevTy lammp)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique counter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: UID | ]

SEM CodeAGItf
  | AGItf       loc         .   gUniq           =   uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ env: REnv | | ]

SEM CodeAGItf
  | AGItf       loc         .   env             =   emptyGam

SEM CBound
  | Bind        expr        .   env             =   gamAddGam @loc.exprEnv @lhs.env
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   exprEnv         =   case @expr.mbLam of
                                                      Just nmL -> gamFromAssocL (zip nmL cs)
                                                        where as = mkNewLevUIDL (length nmL) @lUniq
                                                              bs = map freshAlpha as
                                                              cs = zip bs (repeat Relev_Top)
                                                      Nothing -> emptyGam

SEM CExpr
  | Let         binds       .   env             =   gamAddGam @binds.gathRecEnv @lhs.env
                body        .   env             =   gamAddGam @binds.gathEnv    @lhs.env

SEM CAlt
  | Alt         expr        .   env             =   gamAddGam @pat.gathEnv @lhs.env
%%]

%%[(8 codegen)
ATTR AllBind AllPatFld AllPat CExpr
              [ | | gathEnv    USE {`gamUnion`} {emptyGam}: REnv ]
ATTR AllBind  [ | | gathRecEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CBound
  | Bind        loc         .   gathEnv         =   gamSingleton @lhs.nm (@expr.ty, @gathRelev)
                            .   gathRecEnv      =   gamSingleton @lhs.nm (@expr.ty, @gathRelev)
                            .   gathRelev       =   case @lhs.letBindingsCateg of
                                                      CBindCateg_Strict -> Relev_Rel
                                                      otherwise         -> Relev_Top

SEM CPat
  | Var         lhs         .   gathEnv         =   gamSingleton @pnm (@lhs.knTy, Relev_Top)

SEM CExpr
  | Var         lhs         .   gathEnv         =   gamSingleton @nm (@loc.ty, Relev_Top)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rho env
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ rho: RhoEnv | | gathRho USE {`gamUnion`} {emptyGam}: RhoEnv ]
%%]

%%[(8 codegen)
-- Tying the knot on a per module basis:
SEM CodeAGItf
  | AGItf      module       .   rho             =   @module.gathRho

SEM CExpr
  -- Resetting so it gets contained locally in abstractions:
  | Lam        lhs          .   gathRho         =   emptyGam
  -- | Let
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ knTy: RelTyScheme | | ]

SEM CModule
  | Mod        expr         .   knTy            =   freshUnit

SEM CExpr
  | Lam        bind         .   knTy            =   @loc.alpha1
%%]

%%%[(8 codegen)
-- | the type of the case itself (instead of alternatives)
ATTR AllPat AllAlt [ knTyCase: RelTyScheme | | ]
%%%]

%%%[(8 codegen)
SEM CAltL
  | Cons        hd          .   knTy            =   @altKnDwTy
%%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Relevance annotations down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ knPhi: Relev | | ]

SEM CodeAGItf
  | AGItf       module      .   knPhi           =   Relev_Rel

SEM CExpr
  | Lam         body        .   knPhi           =   Relev_Rel
  | Let         body        .   knPhi           =   @lhs.knPhi
                binds       .   knPhi           =   case @categ of
                                                      CBindCateg_Strict -> Relev_Rel
                                                      CBindCateg_Plain  -> Relev_Top
                                                      CBindCateg_Rec    -> @lhs.knPhi -- TODO
                                                      _                 -> Relev_Top -- Just being safe
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | repl : SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Alts of case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
-- | Constrains an environment to top only elements
constrainEnv :: REnv -> REnv
constrainEnv = let f (k,(t,_)) = (k,(t,Relev_Top))
               in  gamMap f

-- | Performs environment splits with joins
(<>:) :: REnv -> REnv -> REnv
(<>:) = contextSplit True

-- | Performs environment splits with meets
(<>.) :: REnv -> REnv -> REnv
(<>.) = contextSplit False

-- | Performs environment splits with joins (True) or meets (False)
contextSplit :: Bool -> REnv -> REnv -> REnv
contextSplit t e1 e2 = fst $ gamMapThr opE2 [] e1
  where
    op Relev_Top b | t == True = Relev_Top
                   | otherwise = b
    op Relev_Rel b | t == True = b
                   | otherwise = Relev_Rel
    op _         _ = panic "Found a beta for top level annotation!"
    opE2 orig@(k, (tau, rel)) ks | k `elem` ks = (orig, ks) -- Poor man's var masking
                                 | otherwise = let rel2 = snd
                                                          $ panicJust "Splitting contexts with different domains."
                                                          $ gamLookup k e2
                                                   rel' = rel `op` rel2
                                               in  ((k, (tau, rel')), k:ks)
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | retEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CExpr
  -- Updating the gamma before moving back. Let's just hope gamMapThr is always top first.
  | Var         lhs         .   retEnv          =   let updVar (@nm,(tau,_)) True  = ((@nm,(tau,Relev_Rel)),False)
                                                        updVar v             False = (v,False)
                                                    in  fst $ gamMapThr updVar True @lhs.env
  | Lam         loc         .   retEnv          =   let retEnvLocal = snd $ gamPop @body.retEnv
                                                    in  @envTrf retEnvLocal
                            .   envTrf          =   if {- (@loc.gamma `elem` @lhs.rho) -- TODO: Waiting for rhos to be developed
                                                       && -} (@lhs.knPhi == Relev_Rel)
                                                    then constrainEnv
                                                    else id
  | App         lhs         .   retEnv          =   @func.retEnv <>: @arg.retEnv
  | Let         lhs         .   retEnv          =   snd $ gamPop @body.retEnv
  | Case        lhs         .   retEnv          =   @expr.retEnv <>: (@alts.retEnv <>. @dflt.retEnv)
  | * - Var Lam App Let Case lhs.retEnv         =   @lhs.env

SEM CAlt
  | Alt         lhs         .   retEnv          =   snd $ gamPop @expr.retEnv

SEM CAltL
  | Nil         lhs         .   retEnv          =   @lhs.env
  | Cons        lhs         .   retEnv          =   @hd.retEnv <>. @tl.retEnv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr [ | | ty: RelTyScheme ]

SEM CExpr
  -- Value (unit) types are included in the catch all below
  -- More complex types
  | Var         loc         .   ty              =   fromMaybe (freshAlpha @lUniq) -- panicJust ("Variable " ++ show @nm ++ " not in environment.")
                                                    $ renvgLookup @nm @lhs.env @lhs.bindingMp
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Tup         lhs         .   ty              =   freshUnit -- TODO!
  | Lam         lhs         .   ty              =   {- Subst $ -} @loc.alpha1 `freshArrow` @body.ty
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   alpha1          =   freshAlpha @loc.lUniq
  | App         lhs         .   ty              =   {- Subst -} @loc.alpha
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   alpha           =   freshAlpha @loc.lUniq
  | Let         lhs         .   ty              =   @body.ty
  | Case        lhs         .   ty              =   {- Subst -} @alts.ty
  | * - Tup Var Let App Lam Case lhs.ty         =   freshUnit
%%]

%%[(8 codegen)
ATTR CAlt CAltL [ | | ty: RelTyScheme ]

SEM CAlt
  | Alt         lhs         .   ty              =   @expr.ty

SEM CAltL
  | Nil         lhs         .   ty              =   freshAlpha @loc.lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Cons        lhs         .   ty              =   {- Subst -} @hd.ty {- unify with tl.ty -}
%%]

%%[(8 codegen)
ATTR CBind CBoundL CBound [ | | ty: {Maybe RelTyScheme} ]

SEM CBind
  | Bind        loc         .   ty              =   @bindAspects.ty

SEM CBound
  | Bind        lhs         .   ty              =   Just @expr.ty
  | Val         lhs         .   ty              =   Just @expr.ty
%%[[8
  | * - Bind Val lhs        .   ty              =   Nothing
%%][90
  | FFE         lhs         .   ty              =   Just @expr.ty
  | * - Bind Val FFE lhs    .   ty              =   Nothing
%%]]

SEM CBoundL
  | Nil         lhs         .   ty              =   Nothing
  | Cons        lhs         .   ty              =   @hd.ty <|> @tl.ty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Relevance annotations up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr [ | | phi: Relev ]

SEM CExpr
  -- More complex types
  | Var         lhs         .   phi             =   Relev_Rel
  | * - Var Let App Lam Case lhs.phi            =   @lhs.knPhi
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% VarMp gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | rvarMp: RVarMp | ]

SEM CodeAGItf
  | AGItf       loc         .   rvarMp          =   emptyRVarMp

SEM CBound
  | Bind        lhs         .   rvarMp          =   emptyRVarMp -- @quantVarMp |+> @rvarMpExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final VarMp distribution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ finalRVarMp: RVarMp | | ]

SEM CodeAGItf
  | AGItf       module      .   finalRVarMp     =   @module.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint solving, AST driven
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[doesWhat.Case.altQual
Case (and let) expressions only can contribute to the outside constraint solving if it is certain that the constraints will arise.
For case expressions this is only the case if a constraint arises in all alternatives, for a let only when the let is strict.
Solving then needs to be done for the conditionally arising constraints.

20101130: TBD for let expressions.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Variables already bound
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ boundRelevTyVarS: UIDS | | ]
%%]

%%%[(8 codegen)
SEM CBound
  | Bind        expr        .   boundRelevTyVarS=   @exprBoundS
%%%]

%%[(8 codegen)
SEM CModule
  | Mod         expr        .   boundRelevTyVarS=   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllBound [ | | tyAspectL  USE {++} {[]}: {[CBound]} ]
ATTR AllBound [ | | valAspectL USE {++} {[]}: {[CBound]} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: plain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBind
  | Bind       lhs.cTrf  = CBind_Bind @nm (@bindAspects.cTrf ++ [@loc.tyAsp])
               loc.tyAsp = CBound_RelevTy acbaspkeyStrict $ fromMaybe freshUnit @loc.ty
%%]
