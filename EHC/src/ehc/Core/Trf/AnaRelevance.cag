%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analyse Core, using relevance analysis, to relate properties (like relevance) of function args and result, and annotate core expressions with their relevance.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type based simplifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.AnaRelevance} import({%{EH}Ty},{%{EH}Base.Common},{%{EH}Base.TermLike},{%{EH}Base.Builtin},{%{EH}Gam},{%{EH}Opts},{%{EH}Base.Optimize},{%{EH}Core},{%{EH}VarMp},{%{EH}Substitutable})
%%]

%%[(8 codegen) hs import(Data.Maybe, qualified Data.Map as Map, qualified Data.Set as Set, Control.Applicative, Control.Arrow)
%%]

%%[(8 codegen) hs import(UHC.Util.Utils)
%%]

%%[(8 codegen) hs import({%{EH}Foreign.Extract})
%%]
%%[(90 codegen) hs import({%{EH}BuiltinPrims},{%{EH}Foreign})
%%]

%%[(8 codegen) hs import({%{EH}AbstractCore},{%{EH}AnaDomain},{%{EH}AnaDomain.Utils},{%{EH}AnaDomain.Ftv})
%%]

%%[(8 codegen) hs import({%{EH}Gam},{%{EH}Gam.DataGam})
%%]

%%[(8 codegen) hs import({%{EH}BindingInfo})
%%]

%%[(8 codegen) hs import({%{EH}AnaDomain.Trf.Instantiate},{%{EH}AnaDomain.Trf.Subst})
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},UHC.Util.Pretty,{%{EH}AnaDomain.Pretty})
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonFFI},{Core/CommonBindNm},{Core/Trf/CommonStructureInfo},{Core/CommonCtxtPred},{Core/Trf/CommonFv},{Core/CommonBindingInfo},{Core/CommonGathBindingInfo})
WRAPPER CodeAGItf
%%]

%%[(99 codegen)
-- PRAGMA strictcase
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmodTrfAnaRelevance)
cmodTrfAnaRelevance
  :: EHCOpts
     -> DataGam
     -> BindingMp
     -> CModule
     -> ( CModule
        , BindingMp
        )
cmodTrfAnaRelevance
     opts dataGam
     bindingMp
     cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { dataGam_Inh_CodeAGItf = dataGam
                               , bindingMp_Inh_CodeAGItf = bindingMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , gathBindingMp_Syn_CodeAGItf t
          )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering BindingInfo, providing hook for Core/CommonBindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .	howUnionGathBindingInfo
  												=	id
%%]

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .   howMergeBindingInfo	=   (\(BindingInfo {bindinginfoAspMp=m}) i -> i {bindinginfoAspMp = m `Map.union` bindinginfoAspMp i})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Newly bound BindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM CBound
  | Bind        lhs         .   bindingMp   =   let l = [ (acbaspkeyDefaultRelevTy, BindingInfoAsp_RelevTy @bindTy) ]
                                                in  Map.singleton @lhs.nm (emptyBindingInfo {bindinginfoAspMp = Map.fromList l})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam required tags (strictness info), FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type REnv    = Gam HsName (RelTyScheme, Relev)

type RhoEnv  = Gam UID (Set.Set UID)

-- | lookup in local REnv only
renvLookup :: HsName -> REnv -> Maybe (RelTyScheme, Relev)
renvLookup = gamLookup

-- | lookup in REnv first, then global BindingMp
renvgLookup :: HsName -> REnv -> BindingMp -> Maybe RelTyScheme
renvgLookup n renv lammp = (fmap fst $ renvLookup n renv)
                           <|> (fmap libindaspRelevTy $ bindingMpLookupAsp n acbaspkeyDefaultRelevTy lammp)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique counter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: UID | ]

SEM CodeAGItf
  | AGItf       loc         .   gUniq           =   uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ env: REnv | | ]

SEM CodeAGItf
  | AGItf       loc         .   env             =   emptyGam

SEM CExpr
  | Lam         body        .   env             =   gamPushGam @exprEnv @lhs.env
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   exprEnv         =   gamSingleton @argNm (freshAlpha @lUniqAlpha, Relev_Top)
  | App         func        .   env             =   @lhs.env
                arg         .   env             =   @func.rvarMp `varUpd` @lhs.env
  | Let         binds       .   env             =   gamAddGam @binds.gathRecEnv @lhs.env
                body        .   env             =   let newEnv = @binds.rvarMp `varUpd` @lhs.env
                                                        envVars = map (varFreeSet.fst) $ gamElts newEnv
                                                        envVars' = foldr Set.union Set.empty envVars
                                                        gens = gamMapElts (first $ genTySch envVars') @binds.gathRecEnv
                                                    in  gamPushGam gens newEnv
  | Case        expr        .   env             =   @lhs.env
                loc         .   altsEnv         =   @expr.rvarMp `varUpd` @lhs.env
                alts        .   env             =   @altsEnv
                alts        .   altRVarMp       =   @expr.rvarMp
                loc         .   dfltEnv         =   @alts.rvarMp `varUpd` @altsEnv
                dflt        .   env             =   @dfltEnv

SEM CAlt
  | Alt         expr        .   env             =   let upded = @lhs.altRVarMp `varUpd` @pat.gathEnv
                                                    in  gamPushGam upded @lhs.env

ATTR CAlt CAltL [ altRVarMp: RVarMp | | ]
SEM CAltL
  | Cons        tl          .   env             =   @hd.rvarMp `varUpd` @lhs.env
                tl          .   altRVarMp       =   @hd.rvarMp
                hd          .   altRVarMp       =   @lhs.altRVarMp
%%]

%%[(8 codegen)
ATTR AllBind AllPatFld AllPat CExpr
              [ | | gathEnv    USE {`gamUnion`} {emptyGam}: REnv ]
ATTR AllBind  [ | | gathRecEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CBound
  | Bind        loc         .   gathEnv         =   gamSingleton @lhs.nm (@quantTy, @gathRelev)
                            .   gathRecEnv      =   gamSingleton @lhs.nm (@freshTy, @gathRelev)
                            .   gathRelev       =   case @lhs.letBindingsCateg of
                                                      CBindCateg_Strict -> Relev_Rel
                                                      otherwise         -> Relev_Top

SEM CPat
  | Var         lhs         .   gathEnv         =   gamSingleton @pnm (@lhs.knTy, Relev_Top)

SEM CExpr
  | Var         lhs         .   gathEnv         =   gamSingleton @nm (@loc.ty, Relev_Top)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rho env
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ rho: RhoEnv | | gathRho USE {`gamUnion`} {emptyGam}: RhoEnv ]
%%]

%%[(8 codegen)
-- Tying the knot on a per module basis:
SEM CodeAGItf
  | AGItf      module       .   rho             =   @module.gathRho

SEM CExpr
  -- Resetting so it gets contained locally in abstractions:
  | Lam        lhs          .   gathRho         =   emptyGam
  -- | Let
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ knTy: RelTyScheme | | ]

SEM CModule
  | Mod        expr         .   knTy            =   freshUnit
-- TODO!
%%]

%%%[(8 codegen)
-- | the type of the case itself (instead of alternatives)
ATTR AllPat AllAlt [ knTyCase: RelTyScheme | | ]
%%%]

%%%[(8 codegen)
SEM CAltL
  | Cons        hd          .   knTy            =   @altKnDwTy
%%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Relevance annotations down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ knPhi: Relev | | ]

SEM CodeAGItf
  | AGItf       module      .   knPhi           =   Relev_Rel

SEM CExpr
  | Lam         body        .   knPhi           =   Relev_Rel
  | Let         body        .   knPhi           =   @lhs.knPhi
                binds       .   knPhi           =   case @categ of
                                                      CBindCateg_Strict -> Relev_Rel
                                                      CBindCateg_Plain  -> Relev_Top
                                                      CBindCateg_Rec    -> @lhs.knPhi -- TODO
                                                      _                 -> Relev_Top -- Just being safe
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | repl : SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Alts of case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
-- | Constrains an environment to top only elements
constrainEnv :: REnv -> REnv
constrainEnv = let f (k,(t,_)) = (k,(t,Relev_Top))
               in  gamMap f

-- | Performs environment splits with joins
(<>:) :: REnv -> REnv -> REnv
(<>:) = contextSplit True

-- | Performs environment splits with meets
(<>.) :: REnv -> REnv -> REnv
(<>.) = contextSplit False

-- | Performs environment splits with joins (True) or meets (False)
contextSplit :: Bool -> REnv -> REnv -> REnv
contextSplit t e1 e2 = fst $ gamMapThr opE2 [] e1
  where
    op Relev_Top b | t == True = Relev_Top
                   | otherwise = b
    op Relev_Rel b | t == True = b
                   | otherwise = Relev_Rel
    op _         _ = panic "Found a beta for top level annotation!"
    opE2 orig@(k, (tau, rel)) ks | k `elem` ks = (orig, ks) -- Poor man's shadow
                                 | otherwise = let rel2 = snd
                                                          $ panicJust "Splitting contexts with different domains."
                                                          $ gamLookup k e2
                                                   rel' = rel `op` rel2
                                               in  ((k, (tau, rel')), k:ks)
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | retEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CExpr
  -- Updating the gamma before moving back. Let's just hope gamMapThr is always top first.
  | Var         loc         .   retEnv          =   let updVar (@nm,(tau,_)) True  = ((@nm,(tau,Relev_Rel)),False)
                                                        updVar v             False = (v,False)
                                                    in  fst $ gamMapThr updVar True @lhs.env
  | Lam         loc     .(retEnvLocal, retEnv') =   gamPop @body.retEnv
                loc         .   retEnv          =   @envTrf @retEnv'
                            .   envTrf          =   if {- (@loc.gamma `elem` @lhs.rho) -- TODO: Waiting for rhos to be developed
                                                       && -} (@lhs.knPhi == Relev_Rel)
                                                    then constrainEnv
                                                    else id
  | App         loc         .   retEnv          =   (varUpd @arg.rvarMp @func.retEnv) <>: @arg.retEnv
  | Let         loc         .   retEnv          =   snd $ gamPop @body.retEnv
  | Case        loc         .   retEnv          =   let exprEnv = (@dflt.rvarMp |+> @alts.rvarMp) `varUpd` @expr.retEnv
                                                        altsEnv = @dflt.rvarMp `varUpd` @alts.retEnv
                                                    in  exprEnv <>: (altsEnv <>. @dflt.retEnv)
  | * - Var Lam App Let Case lhs.retEnv         =   @lhs.env

SEM CAlt
  | Alt         lhs         .   retEnv          =   snd $ gamPop @expr.retEnv

ATTR CAltL [ | | retMbEnv: (Maybe REnv) ]

SEM CAltL
  | Nil         lhs         .   retMbEnv        =   Nothing
                            .   retEnv          =   @lhs.env
  | Cons        lhs         .   retMbEnv        =   Just @loc.retEnv
                loc         .   retEnv          =   case @tl.retMbEnv of
                                                      Nothing -> @hd.retEnv
                                                      Just env -> (@tl.rvarMp `varUpd` @hd.retEnv) <>. env
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr [ | | ty: RelTyScheme ]

SEM CExpr
  -- Value (unit) types are included in the catch all below
  -- More complex types
  | Var         loc         .   ty              =   let lookup = renvgLookup @nm @lhs.env @lhs.bindingMp
                                                        ty = fromMaybe (freshAlpha @lUniq) lookup
                                                    in  relTySchInst @lUniq ty
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Tup         loc         .   ty              =   freshUnit -- TODO!
  | Lam         loc         .   ty              =   varUpd @body.rvarMp $ @retTy
                loc         .   lUniqGamma      :   UNIQUEREF gUniq
                loc         .   retTy           =   let (_, [(a,p)]) = unzip $ gamToAssocL @retEnvLocal
                                                        gamma = Applic_Gamma @lUniqGamma []
                                                    in  makeArrow p gamma a @body.ty
  | App         loc         .   ty              =   varUpd @unification @loc.alpha
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   alpha           =   freshAlpha @lUniqAlpha
                loc         .   lUniqGamma      :   UNIQUEREF gUniq
                loc         .   gamma           =   Applic_Gamma @lUniqGamma []
                loc         .   unification     =   let tau1 = varUpd @arg.rvarMp @func.ty
                                                        tau2 = makeArrow @arg.phi @gamma
                                                               (panicJust "Argument type error." @arg.ty)
                                                               @alpha
                                                    in  relTySchUnify tau1 tau2
  | Let         loc         .   ty              =   @body.ty
  | Case        loc         .   ty              =   @alts.ty -- FIXME: Should unify with @dflt.ty!
  | Ann         loc         .   ty              =   @expr.ty
  | * - Tup Var Let App Lam Case Ann lhs.ty     =   freshUnit
%%]

%%[(8 codegen)
ATTR CAlt CAltL [ | | ty: RelTyScheme ]

SEM CAlt
  | Alt         lhs         .   ty              =   @expr.ty

SEM CAltL
  | Nil         lhs         .   ty              =   freshAlpha @loc.lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Cons        lhs         .   ty              =   varUpd @unification @hd.ty
                loc         .   unification     =   relTySchUnify @hd.ty @tl.ty
%%]

%%[(8 codegen)
ATTR CBind CBoundL CBound [ | | ty: {Maybe RelTyScheme} ]

SEM CBind
  | Bind        loc         .   ty              =   @bindAspects.ty

SEM CBound
  | Bind        loc         .   ty              =   Just @expr.ty
                loc         .   quantTy         =   case @expr.ty of
                                                      t@(RelTyScheme_Ty a b g (RelTy_Arrow _ _ ty _)) ->
                                                        varUpd @expr.rvarMp $ RelTyScheme_Ty a b g ty
                                                      t -> t
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   freshTy         =   freshAlpha @lUniqAlpha
  | Val         lhs         .   ty              =   Just @expr.ty
%%[[8
  | * - Bind Val lhs        .   ty              =   Nothing
%%][90
  | FFE         lhs         .   ty              =   Just @expr.ty
  | * - Bind Val FFE lhs    .   ty              =   Nothing
%%]]

SEM CBoundL
  | Nil         lhs         .   ty              =   Nothing
  | Cons        lhs         .   ty              =   @hd.ty <|> @tl.ty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Relevance annotations up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr CBound [ | | phi: Relev ]

SEM CExpr
  -- More complex types
  | Var         lhs         .   phi             =   Relev_Rel
  | * - Var Let App Lam Case lhs.phi            =   @lhs.knPhi

SEM CBound
  | Bind        lhs         .   phi             =   @expr.phi
  | * - Bind    lhs         .   phi             =   Relev_Top
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% VarMp gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | rvarMp USE {|+>} {emptyRVarMp}: RVarMp ]

SEM CExpr
  | App         lhs         .   rvarMp          =   @unification
                                                    |+> @func.rvarMp
                                                    |+> @arg.rvarMp

SEM CAltL
  | Cons        lhs         .   rvarMp          =   @unification
                                                    |+> @hd.rvarMp
                                                    |+> @tl.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final VarMp distribution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ finalRVarMp: RVarMp | | ]

SEM CodeAGItf
  | AGItf       module      .   finalRVarMp     =   @module.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint solving, AST driven
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[doesWhat.Case.altQual
Case (and let) expressions only can contribute to the outside constraint solving if it is certain that the constraints will arise.
For case expressions this is only the case if a constraint arises in all alternatives, for a let only when the let is strict.
Solving then needs to be done for the conditionally arising constraints.

20101130: TBD for let expressions.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Variables already bound
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ boundRelevTyVarS: UIDS | | ]
%%]

%%%[(8 codegen)
SEM CBound
  | Bind        expr        .   boundRelevTyVarS=   @exprBoundS
%%%]

%%[(8 codegen)
SEM CModule
  | Mod         expr        .   boundRelevTyVarS=   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllBound [ | | tyAspectL  USE {++} {[]}: {[CBound]} ]
ATTR AllBound [ | | valAspectL USE {++} {[]}: {[CBound]} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: plain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | {- Var Tup -} Let App Lam Case
               lhs.cTrf  = let envPart = gamPartition (\_ (_,p) -> p == Relev_Rel) @loc.retEnv
                               env = gamKeys $ fst envPart
                               finalTy = varUpd @lhs.finalRVarMp @loc.ty
                               ann = CExprAnn_RelTy finalTy env
                           in  CExpr_Ann ann @cTrf

SEM CBind
  | Bind       lhs.cTrf  = CBind_Bind @nm (@bindAspects.cTrf ++ [@loc.tyAsp])
               loc.tyAsp = CBound_RelevTy acbaspkeyStrict $ @bindTy
               loc.bindTy = varUpd @lhs.finalRVarMp $ fromMaybe freshUnit @loc.ty

SEM CBound
  | Bind       loc.bindTy = varUpd @lhs.finalRVarMp $ fromMaybe freshUnit @loc.ty
%%]
