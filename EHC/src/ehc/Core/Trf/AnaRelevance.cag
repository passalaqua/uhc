%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analyse Core, using relevance analysis, to relate properties (like relevance) of function args and result, and annotate core expressions with their relevance.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type based simplifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.AnaRelevance} import({%{EH}Ty},{%{EH}Base.Common},{%{EH}Base.TermLike},{%{EH}Base.Builtin},{%{EH}Gam},{%{EH}Opts},{%{EH}Base.Optimize},{%{EH}Core},{%{EH}VarMp},{%{EH}Substitutable})
%%]

%%[(8 codegen) hs import(Data.Maybe, qualified Data.Map as Map, qualified Data.Set as Set, Control.Applicative, Control.Arrow)
%%]

%%[(8 codegen) hs import(UHC.Util.Utils)
%%]

%%[(8 codegen) hs import({%{EH}Foreign.Extract})
%%]
%%[(90 codegen) hs import({%{EH}BuiltinPrims},{%{EH}Foreign})
%%]

%%[(8 codegen) hs import({%{EH}AbstractCore},{%{EH}AnaDomain},{%{EH}AnaDomain.Utils},{%{EH}AnaDomain.Ftv})
%%]

%%[(8 codegen) hs import({%{EH}Gam},{%{EH}Gam.DataGam})
%%]

%%[(8 codegen) hs import({%{EH}BindingInfo})
%%]

%%[(8 codegen) hs import({%{EH}AnaDomain.Trf.Instantiate},{%{EH}AnaDomain.Trf.Subst},{%{EH}AnaDomain.Trf.TyTrans})
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},UHC.Util.Pretty,{%{EH}AnaDomain.Pretty})
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonFFI},{Core/CommonBindNm},{Core/Trf/CommonStructureInfo},{Core/CommonCtxtPred},{Core/Trf/CommonFv},{Core/CommonBindingInfo},{Core/CommonGathBindingInfo})
WRAPPER CodeAGItf
%%]

%%[(99 codegen)
-- PRAGMA strictcase
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmodTrfAnaRelevance)
cmodTrfAnaRelevance
  :: EHCOpts
     -> DataGam
     -> BindingMp
     -> CModule
     -> ( CModule
        , BindingMp
        )
cmodTrfAnaRelevance
     opts dataGam
     bindingMp
     cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { dataGam_Inh_CodeAGItf = dataGam
                               , bindingMp_Inh_CodeAGItf = bindingMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , gathBindingMp_Syn_CodeAGItf t
          )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering BindingInfo, providing hook for Core/CommonBindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .	howUnionGathBindingInfo
  												=	id
%%]

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       loc         .   howMergeBindingInfo	=   (\(BindingInfo {bindinginfoAspMp=m}) i -> i {bindinginfoAspMp = m `Map.union` bindinginfoAspMp i})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Newly bound BindingInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM CBound
  | Bind        lhs         .   bindingMp   =   let l = [ (acbaspkeyDefaultRelevTy, BindingInfoAsp_RelevTy @bindTy) ]
                                                in  Map.singleton @lhs.nm (emptyBindingInfo {bindinginfoAspMp = Map.fromList l})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam required tags (strictness info), FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type REnv    = Gam HsName (RelTyScheme, Relev)

type RhoEnv  = Gam UID (Set.Set UID)

-- | lookup in local REnv only
renvLookup :: HsName -> REnv -> Maybe (RelTyScheme, Relev)
renvLookup = gamLookup

-- | lookup in REnv first, then global BindingMp
renvgLookup :: HsName -> REnv -> UID -> DataGam -> BindingMp -> Maybe RelTyScheme
renvgLookup n renv uniq dg lammp = (fst <$> renvLookup n renv)
                                   <|> (libindaspRelevTy
                                        <$> bindingMpLookupAsp n acbaspkeyDefaultRelevTy lammp)
--                                   <|> ((relTyFromTy uniq dg.libindaspTy)
--                                        <$> bindingMpLookupAsp n acbaspkeyDefaultTy lammp)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique counter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: UID | ]

SEM CodeAGItf
  | AGItf       loc         .   gUniq           =   uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ env: REnv | | ]

SEM CodeAGItf
  | AGItf       loc         .   env             =   emptyGam

SEM CExpr
  | Lam         body        .   env             =   gamPushGam @exprEnv @lhs.env
                bind        .   env             =   @exprEnv
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   exprEnv         =   gamSingleton @argNm (freshAlpha @lUniqAlpha, Relev_Top)
  | App         func        .   env             =   @lhs.env
                arg         .   env             =   @func.rvarMp `varUpd` @lhs.env
  | Let         body        .   env             =   let newEnv = @binds.rvarMp `varUpd` @lhs.env
                                                        envVars = map (varFreeSet.fst) $ gamElts newEnv
                                                        envVars' = foldr Set.union Set.empty envVars
                                                        gens = gamMapElts (first $ genTySch envVars') $ @binds.rvarMp `varUpd` @binds.gathEnv
                                                    in  gamPushGam gens newEnv
  | Case        expr        .   env             =   @lhs.env
                loc         .   altsEnv         =   @expr.rvarMp `varUpd` @lhs.env
                alts        .   env             =   @altsEnv
                alts        .   altRVarMp       =   @expr.rvarMp
                loc         .   dfltEnv         =   @alts.rvarMp `varUpd` @altsEnv
                dflt        .   env             =   @dfltEnv

SEM CAlt
  | Alt         expr        .   env             =   let updated = @lhs.altRVarMp `varUpd` @pat.gathEnv
                                                    in  gamPushGam updated @lhs.env

ATTR CAlt CAltL [ altRVarMp: RVarMp | | ]
SEM CAltL
  | Cons        tl          .   env             =   @hd.rvarMp `varUpd` @lhs.env
                tl          .   altRVarMp       =   @hd.rvarMp
                hd          .   altRVarMp       =   @lhs.altRVarMp
%%]

%%[(8 codegen)
ATTR AllBind AllPatFld AllPat CExpr
              [ | | gathEnv    USE {`gamUnion`} {emptyGam}: REnv ]
ATTR AllBind  [ | | gathRecEnv USE {`gamUnion`} {emptyGam}: REnv ]
ATTR CBindL   [ gathRecEnvKn : REnv | | ]

SEM CExpr
  | Let         binds       .   gathRecEnvKn    =   @binds.gathRecEnv

SEM CBindL
  | Cons        hd          .   env             =   case @lhs.categ of
                                                      Just (CBindCateg_Rec) -> gamPushGam @lhs.gathRecEnvKn @lhs.env
                                                      _                     -> @lhs.env

SEM CBound
  | Bind        loc         .   gathEnv         =   gamSingleton @lhs.nm (@quantTy, @lhs.knPhi)
                            .   gathRecEnv      =   case @lhs.categ of
                                                      Just (CBindCateg_Rec)    -> let phi = Relev_Beta @lUniqREBeta
                                                                                      psi = Applic_Gamma @lUniqREGamma []
                                                                                      -- TODO: Might be a good idea to add phi and psi to the gen sets below
                                                                                      ty = freshTySch $ RelTy_Arrow phi psi @freshTy @freshTy
                                                                                  in  gamSingleton @lhs.nm (ty, Relev_Top)
                                                      _                        -> emptyGam
                loc         .   lUniqREBeta     :   UNIQUEREF gUniq
                loc         .   lUniqREGamma    :   UNIQUEREF gUniq

SEM CPat
  | Var         lhs         .   gathEnv         =   gamSingleton @pnm (@lhs.knTy, Relev_Top)
--  | Con         lhs         .   gathEnv         =   gamSingleton -- TODO!

SEM CExpr
  | Var         lhs         .   gathEnv         =   gamSingleton @nm (@loc.ty, Relev_Top)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rho env
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ rho: UIDS | | gathRho USE {`Set.union`} {Set.empty}: {Set.Set Applic} ]
ATTR CAltL [ | | mbGathRho: {Maybe (Set.Set Applic)} ]
ATTR CBindL [ | | bindsGathRho: {Set.Set Applic} ]

-- Tying the knot on a per module basis:
SEM CodeAGItf
  | AGItf      module       .   rho             =   let uids = liftM uidFromGamma @module.gathRho
                                                    in  Set.fromJust <$> (filter isJust) uids

SEM CExpr
  -- Resetting so it gets contained locally in abstractions:
  | Lam        lhs          .   gathRho         =   Set.empty
  | App        lhs          .   gathRho         =   let local = Set.singleton $ (varUpd @rvarMp @gamma)
                                                    in  @func.gathRho `Set.union` @arg.gathRho `Set.union` local
  | Let        loc          .   bindsGathRho    =   case @categ of
                                                      CBindCateg_Strict -> @binds.gathRho
                                                      CBindCateg_Plain  -> @binds.bindsGathRho
                                                      _                 -> Set.empty
               lhs          .   gathRho         =   @body.gathRho `Set.union` @bindsGathRho

SEM CBindL
  | Nil        lhs          .   bindsGathRho    =   Set.empty
                                                    -- FIXME: This should be safe for letrec, but it's not what my algorithm describes
  | Cons       lhs          .   bindsGathRho    =   if (varUpd @lhs.finalRVarMp (fromMaybe Relev_Top @knPhi) == Relev_Rel)
                                                    then @tl.bindsGathRho `Set.union` @hd.gathRho
                                                    else @tl.bindsGathRho

SEM CAltL
  | Nil        lhs          .   mbGathRho       =   Nothing
  | Cons       loc          .   mbGathRho       =   do tl <- @tl.mbGathRho
                                                       return (tl `Set.intersection` @hd.gathRho)
                                                    <|> Just @hd.gathRho
               lhs          .   gathRho         =   fromJust @mbGathRho
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ knTy: RelTyScheme | | ]

SEM CModule
  | Mod        expr         .   knTy            =   freshUnit
-- TODO!
%%]

%%[(8 codegen)
-- | the type of the case itself (instead of alternatives)
ATTR AllPat AllAlt [ knTyCase: RelTyScheme | | ]

SEM CExpr
  | Case        alts        .   knTyCase        =   @expr.ty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Relevance annotations down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ knPhi: Relev | | ]

SEM CodeAGItf
  | AGItf       module      .   knPhi           =   Relev_Rel

SEM CExpr
  | Lam         body        .   knPhi           =   Relev_Rel
                bind        .   categ           =   Nothing
  | App         func        .   knPhi           =   @lhs.knPhi
                arg         .   knPhi           =   @argPhi
                loc         .   lUniqArgPhi     :   UNIQUEREF gUniq
                loc         .   argPhi          =   Relev_Beta @lUniqArgPhi
                arg         .   categ           =   Nothing
  | Let         body        .   knPhi           =   @lhs.knPhi
                binds       .   knPhi           =   @lhs.knPhi -- Not supposed to be used
                binds       .   categ           =   Just @categ

ATTR CBindL CBind CBound [ categ: {Maybe CBindCateg} | | ]
SEM CBindL
  | Cons        loc         .   knPhi           =   do categ <- @lhs.categ
                                                       let ret = case categ of
                                                                   CBindCateg_Strict -> Relev_Rel
                                                                   CBindCateg_Plain  -> Relev_Beta @lUniqBeta
                                                                   CBindCateg_Rec    -> Relev_Beta @lUniqBeta
                                                       return ret
                hd          .   knPhi           =   fromMaybe Relev_Top @knPhi
                tl          .   knPhi           =   Relev_Top
                loc         .   lUniqBeta       :   UNIQUEREF gUniq

SEM CBoundL
  | Cons        hd          .   categ           =   Nothing

SEM CPatFld
  | Fld         bind        .   categ           =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | repl : SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Alts of case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
-- | Constrains an environment to top only elements
constrainEnv :: REnv -> REnv
constrainEnv = let f (k,(t,_)) = (k,(t,Relev_Top))
               in  gamMap f

-- | Conditionally constrains an environmnet to top only elements
(>?) :: Relev -> REnv -> REnv
(>?) Relev_Top = constrainEnv
(>?) _         = id

-- | Performs environment splits with joins
(<>:) :: REnv -> REnv -> REnv
(<>:) = contextSplit join

-- | Performs environment splits with meets
(<>.) :: REnv -> REnv -> REnv
(<>.) = contextSplit meet

-- | Performs environment splits with joins or meets
contextSplit :: (Relev -> Relev -> Relev) -> REnv -> REnv -> REnv
contextSplit op e1 e2 = fst $ gamMapThr opE2 [] e1
  where
    opE2 orig@(k, (tau, rel)) ks | k `elem` ks = (orig, ks) -- Poor man's shadow
                                 | otherwise = let rel2 = snd
                                                          $ panicJust "Splitting contexts with different domains."
                                                          $ gamLookup k e2
                                                   rel' = rel `op` rel2
                                               in  ((k, (tau, rel')), k:ks)
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | retEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CExpr
  | Int Char String      lhs.   retEnv          =   @lhs.env
%%[[(97 codegen)
  | Integer     lhs         .   retEnv          =   @lhs.env
%%]]
  -- Updating the gamma before moving back. Let's just hope gamMapThr is always top first.
  | Var         loc         .   retEnv          =   let updVar (nm,(tau,_)) True | nm == @nm = ((@nm,(tau,@lhs.knPhi)),False)
                                                        updVar v            b    = (v,b)
                                                    in  fst $ gamMapThr updVar True @lhs.env
  | Lam         loc     .(retEnvLocal,retEnv')  =   gamPop @body.retEnv
                loc         .   retEnv          =   if @loc.lUniqGamma `Set.member` @lhs.rho
                                                    then @lhs.knPhi >? @retEnv'
                                                    else @retEnv'
  | App         loc         .   retEnv          =   (varUpd @arg.rvarMp @func.retEnv) <>. @arg.retEnv
  | Let         loc         .   retEnv          =   let (_,bodyEnv) = gamPop @body.retEnv
                                                    in  bodyEnv <>. @binds.retEnv
  | Case        loc         .   retEnv          =   let exprEnv = (@dflt.rvarMp |+> @alts.rvarMp) `varUpd` @expr.retEnv
                                                        altsEnv = @dflt.rvarMp `varUpd` @alts.retEnv
                                                    in  exprEnv <>. (altsEnv <>: @dflt.retEnv)

SEM CAlt
  | Alt         lhs         .   retEnv          =   snd $ gamPop @expr.retEnv

ATTR CAltL [ | | retMbEnv: (Maybe REnv) ]

SEM CAltL
  | Nil         lhs         .   retMbEnv        =   Nothing
                            .   retEnv          =   @lhs.env
  | Cons        lhs         .   retMbEnv        =   Just @loc.retEnv
                loc         .   retEnv          =   case @tl.retMbEnv of
                                                      Nothing -> @hd.retEnv
                                                      Just env -> (@tl.rvarMp `varUpd` @hd.retEnv) <>: env

SEM CBindL
  | Nil         lhs         .   retEnv          =   @lhs.env
  | Cons        lhs         .   retEnv          =   case @lhs.categ of
                                                      Just (CBindCateg_Strict) -> @hd.retEnv
                                                      Just (CBindCateg_Plain)  -> (fromJust @knUpdPhi) >? @hd.retEnv
                                                      Just (CBindCateg_Rec)    -> let (_,env) = gamPop @hd.retEnv
                                                                                  in  ((fromJust @knUpdPhi) >? env) <>. @tl.retEnv
                                                      _                        -> emptyGam
                loc         .   knUpdPhi        =   do phi <- @knPhi
                                                       return $ @lhs.finalRVarMp `varUpd` phi
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr CBind [ | | ty: RelTyScheme ]

SEM CExpr
  -- Value (unit) types are included in the catch all below
  -- More complex types
  | Var         loc         .   (ty,rho)        =   let lookup = renvgLookup @nm @lhs.env @lUniq @lhs.dataGam @lhs.bindingMp
                                                        ty = fromMaybe (freshAlpha @lUniq) lookup
                                                    in  relTySchInst @lhs.gUniq ty
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Tup         loc         .   ty              =   fromMaybe id @loc.mbArrows $ freshData @tag
                loc         .   mbArrows        =   do (_,dti) <- @loc.dataInfo
                                                       let anns = dtiConFldAnnL dti
                                                       let alphas = freshAlpha <$> (mkNewLevUIDL (length anns) @lUniqAlphas)
                                                       let phis   = (\(DataConFldAnnInfo x) -> case x of
                                                                        Strictness_Strict -> Relev_Rel
                                                                        _ -> Relev_Top) <$> anns
                                                       let gammas = Applic_Gamma <$> (mkNewLevUIDL (length anns) @lUniqGammas) <*> (repeat [])
                                                       let arrows = makeArrow <$> phis <*> gammas <*> alphas
                                                       return $ foldr (.) id arrows
                loc         .   dataInfo        =   dataGamTagLookup @tag @lhs.dataGam
                loc         .   lUniqAlphas     :   UNIQUEREF gUniq
                loc         .   lUniqGammas     :   UNIQUEREF gUniq
  | Lam         loc         .   ty              =   varUpd @body.rvarMp @retTy
                loc         .   lUniqGamma      :   UNIQUEREF gUniq
                loc         .   retTy           =   let (_, [(a,p)]) = unzip $ gamToAssocL @retEnvLocal
                                                        gamma = Applic_Gamma @lUniqGamma []
                                                    in  makeArrow p gamma a @body.ty
  | App         loc         .   ty              =   varUpd @rvarMp @loc.alpha
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   alpha           =   freshAlpha @lUniqAlpha
                loc         .   lUniqAPhi       :   UNIQUEREF gUniq
                loc         .   arrowPhi        =   Relev_Beta @lUniqAPhi
                loc         .   lUniqGamma      :   UNIQUEREF gUniq
                loc         .   gamma           =   Applic_Gamma @lUniqGamma []
                loc         .   extraUnif       =   let tau1 = varUpd @arg.rvarMp @func.ty
                                                        tau2 = makeArrow @arrowPhi @gamma
                                                               (panicJust "Argument type error." @arg.mbTy)
                                                               @alpha
                                                        sub1 = relTySchUnify tau1 tau2
                                                        sub2 = rvmpRelev @lUniqArgPhi @arrowPhi
                                                    in  sub1 |+> sub2
  | Let         loc         .   ty              =   @body.ty
  | Case        loc         .   ty              =   @alts.ty -- FIXME: Should unify with @dflt.ty!
  | Ann         loc         .   ty              =   @expr.ty
  | * - Tup Var Let App Lam Case Ann lhs.ty     =   freshUnit

SEM CBind
  | Bind        loc         .   ty              =   let fresh = freshAlpha @lUniqAlpha
                                                        envVals = @bindAspects.mbTy <|> (fst <$> renvLookup @nm @lhs.env)
                                                    in  fromMaybe fresh envVals
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
%%]

%%[(8 codegen)
ATTR CAlt CAltL [ | | ty: RelTyScheme ]

SEM CAlt
  | Alt         loc         .   ty              =   @expr.ty
                loc         .   unification     =   relTySchUnify @ty @lhs.knTyCase

SEM CAltL
  | Nil         lhs         .   ty              =   freshAlpha @loc.lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Cons        lhs         .   ty              =   varUpd @unification @hd.ty
                loc         .   unification     =   relTySchUnify @hd.ty @tl.ty
%%]

%%[(8 codegen)
ATTR CBoundL CBound [ | | mbTy: {Maybe RelTyScheme} ]

SEM CBound
  | Bind        loc         .   mbTy            =   Just @expr.ty
                loc         .   lUniqAlpha      :   UNIQUEREF gUniq
                loc         .   freshTy         =   RelTy_Alpha @lUniqAlpha
                loc         .   quantTy         =   case @lhs.categ of
                                                      Just (CBindCateg_Rec) -> freshTySch @freshTy
                                                      _                     -> @expr.ty
  | Val         lhs         .   mbTy            =   Just @expr.ty
%%[[8
  | * - Bind Val lhs        .   mbTy            =   Nothing
%%][90
  | FFE         lhs         .   mbTy            =   Just @expr.ty
  | * - Bind Val FFE lhs    .   mbTy            =   Nothing
%%]]

SEM CBoundL
  | Nil         lhs         .   mbTy            =   Nothing
  | Cons        lhs         .   mbTy            =   @hd.mbTy <|> @tl.mbTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% VarMp gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | rvarMp USE {|+>} {emptyRVarMp}: RVarMp ]

SEM CExpr
  | App         loc         .   rvarMp          =   @extraUnif
                                                    |+> @func.rvarMp
                                                    |+> @arg.rvarMp

SEM CAlt
  | Alt         lhs         .   rvarMp          =   @unification
                                                    |+> @pat.rvarMp
                                                    |+> @expr.rvarMp

SEM CAltL
  | Cons        lhs         .   rvarMp          =   @unification
                                                    |+> @hd.rvarMp
                                                    |+> @tl.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final VarMp distribution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ finalRVarMp: RVarMp | | ]

SEM CodeAGItf
  | AGItf       module      .   finalRVarMp     =   @module.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint solving, AST driven
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllBound [ | | tyAspectL  USE {++} {[]}: {[CBound]} ]
ATTR AllBound [ | | valAspectL USE {++} {[]}: {[CBound]} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: plain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | {- Var Tup -} Let App Lam Case
               lhs.cTrf  = let envPart = gamPartition (\_ (_,p) -> p == Relev_Rel) @loc.retEnv
                               env = gamKeys $ fst envPart
                               finalTy = varUpd @lhs.finalRVarMp @loc.ty
                               ann = CExprAnn_RelTy finalTy env
                           in  CExpr_Ann ann @cTrf

SEM CBind
  | Bind       lhs.cTrf  = CBind_Bind @nm (@bindAspects.cTrf ++ [@loc.tyAsp])
               loc.tyAsp = CBound_RelevTy acbaspkeyStrict $ @bindTy
               loc.bindTy = varUpd @lhs.finalRVarMp @loc.ty

SEM CBound
  | Bind       loc.bindTy = varUpd @lhs.finalRVarMp @expr.ty
%%]
