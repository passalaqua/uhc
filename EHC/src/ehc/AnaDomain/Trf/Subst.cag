%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to AnaDomain subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[doesWhat doclatex
Substitution for AnaDomain.
%%]

%%[(8 codegen) hs module {%{EH}AnaDomain.Trf.Subst} import({%{EH}Base.Common},{%{EH}AnaDomain},{%{EH}VarMp})
%%]

%%[(8 codegen) hs import(UHC.Util.Utils)
%%]
%%[(8 codegen) hs import(Data.Set)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) ag import({AnaDomain/AbsSyn})
WRAPPER TyAGItf
%%]

%%[(8 codegen) hs export(relTySchAppVarLookup)
relTySchAppVarLookup :: VarLookup m UID RVarMpInfo => m -> RelTyScheme -> RelTyScheme
relTySchAppVarLookup varmp ty
  = repl_Syn_TyAGItf t
  where t = wrap_TyAGItf
              (sem_TyAGItf (TyAGItf_AGItf ty))
              (Inh_TyAGItf {rvarLookup_Inh_TyAGItf = varlookupFix varmp})
%%]

%%[(8 codegen) hs export(relTySchUnify)
relTySchUnify :: RelTyScheme -> RelTyScheme -> RVarMp
relTySchUnify t1 t2 = emptyRVarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% VarMp
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR TyAGItf AllNT [ rvarLookup: {VarLookupFix UID RVarMpInfo} | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM RelTy
  | Alpha           inst    .   repl'       :   RelTy
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ rvmiMbTy $? @lhs.rvarLookup @v
                    inst    .   repl'       =   if @isRepl then @replv else RelTy_Unit

SEM Relev
  | Beta            inst    .   repl'       :   Relev
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ rvmiMbRel $? @lhs.rvarLookup @v
                    inst    .   repl'       =   if @isRepl then @replv else Relev_Top

SEM Applic
  | Gamma           inst    .   repl'       :   Applic
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ rvmiMbApp $? @lhs.rvarLookup @v
                    inst    .   repl'       =   if @isRepl then @replv else Applic_Top
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Apply substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT     [ | | repl: SELF  		]
ATTR TyAGItf   [ | | repl: RelTyScheme    	]
%%]

%%[(8 codegen)
SEM RelTyScheme
  | Ty              loc     .   rvarLookup  =   let quants = @alphas `union` @betas `union` @gammas
                                                    quants' = toList quants
                                                in  varlookupFixDel quants' @lhs.rvarLookup

SEM RelTy
  | Alpha           lhs     .   repl        =   if @isRepl
                                                then @repl'.repl
                                                else @repl

SEM Relev
  | Beta            lhs     .   repl        =   if @isRepl
                                                then @repl'.repl
                                                else @repl

SEM Applic
  | Gamma           lhs     .   repl        =   if @isRepl
                                                then @repl'.repl
                                                else @repl
%%]
