%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% AnaDomain Pretty Printer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}AnaDomain.Pretty} import(UHC.Util.Pretty,{%{EH}AnaDomain})
%%]

%%[(8 codegen) hs import({%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Char)
%%]

%%[(8 codegen).WRAPPER ag import({AnaDomain/AbsSyn})
WRAPPER
  AllNT
%%]

%%[(8 codegen) hs export(ppRelTySch)
ppRelTySch :: RelTyScheme -> PP_Doc
ppRelTySch x
  =  let  t = wrap_RelTyScheme (sem_RelTyScheme x)
                               (Inh_RelTyScheme  )
     in   pp_Syn_RelTyScheme t

instance PP RelTyScheme where
  pp = ppRelTySch
%%]

%%[(8 codegen) hs export(ppRelTy)
ppRelTy :: RelTy -> PP_Doc
ppRelTy x
  =  let  t = wrap_RelTy (sem_RelTy x)
                         (Inh_RelTy {parNeed_Inh_RelTy=False})
     in   pp_Syn_RelTy t

instance PP RelTy where
  pp = ppRelTy
%%]

%%[(8 codegen) hs export(ppRelRel)
ppRelRel :: Relev -> PP_Doc
ppRelRel x
  =  let  t = wrap_Relev (sem_Relev x)
                         (Inh_Relev  )
     in   pp_Syn_Relev t

instance PP Relev where
  pp = ppRelRel
%%]

%%[(8 codegen) hs export(ppRelApp)
ppRelApp :: Applic -> PP_Doc
ppRelApp x
  =  let  t = wrap_Applic (sem_Applic x)
                          (Inh_Applic  )
     in   pp_Syn_Applic t

instance PP Applic where
  pp = ppRelApp
%%]

%%[(8 codegen) hs
instance Show RVarMpInfo where
  show _ = "RVarMpInfo"

instance PP RVarMpInfo where
  pp (RVMIType   a) = pp a
  pp (RVMIRelev  r) = pp r
  pp (RVMIApplic a) = pp a
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pretty printed code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | pp USE {>-<} {empty} : PP_Doc ]

SEM RelTyScheme
  | Ty          lhs         .   pp          =   @loc.alpha >|< @loc.beta >|< @loc.gamma >|< @ty.pp
                ty          .   parNeed     =   False
                loc         .   alpha       =   if Set.null @alphas then empty else pp "\\a/" >|< ppParens (show @alphas)
                loc         .   beta        =   if Set.null @betas  then empty else pp "\\b/" >|< ppParens (show @betas)
                loc         .   gamma       =   if Set.null @gammas then empty else pp "\\g/" >|< ppParens (show @gammas)

ATTR RelTy [ parNeed : Bool | | ]

SEM RelTy
  | Unit        lhs         .   pp          =   pp "()"
  | Alpha       lhs         .   pp          =   pp @v
  | Arrow       lhs         .   pp          =   let wrap = if @lhs.parNeed then ppParens else id
                                                in  wrap $ @arg.pp >#< "-" >|< ppParens (@phi.pp >|< "," >|< @psi.pp) >|< "->" >#< @res.pp
                arg         .   parNeed     =   True
                res         .   parNeed     =   False
  | Data        lhs         .   pp          =   pp "D" >|< ppParensCommas @params.ppL

SEM RelTyL
  | Cons        hd          .   parNeed     =   False

SEM Relev
  | Top         lhs         .   pp          =   pp "T"
  | Rel         lhs         .   pp          =   pp "R"
  | Beta        lhs         .   pp          =   "B" >|< pp @v
  | Meet        lhs         .   pp          =   ppParens (@a.pp >#< "/\\" >#< @b.pp)
  | Join        lhs         .   pp          =   ppParens (@a.pp >#< "\\/" >#< @b.pp)

SEM Applic
  | Top         lhs         .   pp          =   pp "T"
  | App         lhs         .   pp          =   pp "A"
  | Gamma       lhs         .   pp          =   let g = "G" >|< pp @v
                                                in  if null @deps.ppL then g else ppBrackets (g >#< "+->" >#< ppCommas @deps.ppL)
  | Meet        lhs         .   pp          =   ppParens (@a.pp >#< "/\\" >#< @b.pp)
  | Join        lhs         .   pp          =   ppParens (@a.pp >#< "\\/" >#< @b.pp)
%%]

%%[(8 codegen)
SEM RelTyL Rho [ | | ppL: {[PP_Doc]} ]
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   @hd.pp : @tl.ppL
%%]
