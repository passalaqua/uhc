%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% AnaDomain Pretty Printer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}AnaDomain.Pretty} import(UHC.Util.Pretty,{%{EH}AnaDomain})
%%]

%%[(8 codegen) hs import({%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Char)
%%]

%%[(8 codegen).WRAPPER ag import({AnaDomain/AbsSyn})
WRAPPER
  RelTyScheme RelTy
%%]

%%[(8 codegen) hs export(ppRelTySch)
ppRelTySch :: RelTyScheme -> PP_Doc
ppRelTySch x
  =  let  t = wrap_RelTyScheme (sem_RelTyScheme x)
                               (Inh_RelTyScheme { alphas_Inh_RelTyScheme = Set.empty
                                                , betas_Inh_RelTyScheme = Set.empty
                                                , gammas_Inh_RelTyScheme = Set.empty
                                                })
     in   pp_Syn_RelTyScheme t

instance PP RelTyScheme where
  pp = ppRelTySch
%%]

%%[(8 codegen) hs export(ppRelTy)
ppRelTy :: RelTy -> PP_Doc
ppRelTy x
  =  let  t = wrap_RelTy (sem_RelTy x)
                         (Inh_RelTy  )
     in   pp_Syn_RelTy t

instance PP RelTy where
  pp = ppRelTy
%%]

%%[(8 codegen) hs
instance Show RVarMpInfo where
  show _ = "RVarMpInfo"

instance PP RVarMpInfo where
  pp (RVMIType a) = pp a
  pp (RVMIRelev ) = empty
  pp (RVMIApplic) = empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pretty printed code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | | pp USE {>-<} {empty} : PP_Doc ]

ATTR TyAGItf RelTyScheme RelTySchemeL [ alphas : {UIDS} | | ]
ATTR TyAGItf RelTyScheme RelTySchemeL [ betas  : {UIDS} | | ]
ATTR TyAGItf RelTyScheme RelTySchemeL [ gammas : {UIDS} | | ]

SEM RelTyScheme
  | Tau         lhs         .   pp          =   @loc.alpha >#< @loc.beta >#< @loc.gamma >#< @ty.pp
                loc         .   alpha       =   if Set.null @lhs.alphas then empty else pp "\\a/" >|< ppParens (show @lhs.alphas)
                loc         .   beta        =   if Set.null @lhs.betas  then empty else pp "\\b/" >|< ppParens (show @lhs.betas)
                loc         .   gamma       =   if Set.null @lhs.gammas then empty else pp "\\g/" >|< ppParens (show @lhs.gammas)
  | * - Tau     lhs         .   pp          =   @ty.pp
  | FAAlpha     ty          .   alphas      =   Set.insert @alpha @lhs.alphas
  | FABeta      ty          .   betas       =   Set.insert @beta @lhs.betas
  | FAGamma     ty          .   gammas      =   Set.insert @gamma @lhs.gammas

SEM RelTy
  | Unit        lhs         .   pp          =   pp "()"
  | Alpha       lhs         .   pp          =   pp @v
  | Arrow       lhs         .   pp          =   @arg.pp >|< pp "-(" >|< @phi.pp >|< pp "," >|< @psi.pp >|< pp ")->" >|< @res.pp
  | Data        lhs         .   pp          =   pp "D" >|< ppParens (show @params.ppL)

SEM Relev
  | Top         lhs         .   pp          =   pp "T"
  | Rel         lhs         .   pp          =   pp "R"
  | Beta        lhs         .   pp          =   pp ("B" ++ show @v)

SEM Applic
  | Top         lhs         .   pp          =   pp "T"
  | App         lhs         .   pp          =   pp "A"
  | Gamma       lhs         .   pp          =   if null @deps.ppL then pp ("G" ++ show @v) else ppBrackets (("G" ++ show @v ++ "+->") >|< @deps.ppL)
%%]

%%[(8 codegen)
SEM RelTySchemeL RelTyL Rho [ | | ppL: {[PP_Doc]} ]
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   @hd.pp : @tl.ppL
%%]
